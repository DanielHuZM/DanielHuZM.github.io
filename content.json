[{"title":"Socket I/O复用","date":"2020-05-03T05:32:00.000Z","path":"2020/05/03/No19-Socket-I-O复用/","excerpt":"前言​ select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。 select1int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);","tags":[{"name":"Socket","slug":"Socket","permalink":"http://yoursite.com/tags/Socket/"},{"name":"I/O复用","slug":"I-O复用","permalink":"http://yoursite.com/tags/I-O复用/"}]},{"title":"Python源码试读--常见容器的底层实现(Dict)","date":"2020-05-02T15:44:54.000Z","path":"2020/05/02/No18-Python源码试读-dict的底层实现/","excerpt":"前言​ 元素和元素之间可能存在着某种关系，比如学生姓名和成绩。我希望能够通过学生的姓名找到这个学生的成绩，那么只需要将两者关联起来即可。字典正是这么做的，字典中的每个元素就是一个key:value键值对，通过指定的key可以找到value。字典这种数据结构，python底层也在大量的使用，比如每一个类都有自己的属性字典，这就意味着python对字典这种数据结构的性能要求是极其苛刻的。所以在python底层，对字典这种数据结构进行了高度的优化。理论上，字典查找元素的时间复杂度是O(1)。那么我们来看一下PyDictObject，为什么字典的查找效率是O(1)，它底层是使用了什么原理。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"Dict","slug":"Dict","permalink":"http://yoursite.com/tags/Dict/"}]},{"title":"Python源码试读--sort底层实现","date":"2020-05-02T10:08:05.000Z","path":"2020/05/02/NO17-Python源码试读-sort底层实现/","excerpt":"前言​ 上一篇文章我介绍了在Cpython中是如何实现List的，作为list的重要方法sort，它的内部实现机制是什么没时间复杂度是多少呢？本文将对此展开介绍。Timsort是结合了合并排序（merge sort）和折半排序（binary sort）而得出的排序算法，它在现实中有很好的效率。Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，然后按规则合并这些run。Pyhton自从2.3版以来一直采用Timsort算法排序，现在Java SE7和Android也采用Timsort算法对数组排序。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"List","slug":"List","permalink":"http://yoursite.com/tags/List/"},{"name":"Sort","slug":"Sort","permalink":"http://yoursite.com/tags/Sort/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"Python源码试读--常见容器的底层实现(List)","date":"2020-05-02T06:11:50.000Z","path":"2020/05/02/No16-Python中常见容器的底层实现/","excerpt":"前言​ Python中的常见容器有以下几种：列表(List)、集合(Set)、元祖(Tuple)、字典(Dict)等。下文会从Cpython的源码入手，看看这些常见容器在底层是如何实现的。今天先来看下最简单的List。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"List","slug":"List","permalink":"http://yoursite.com/tags/List/"},{"name":"容器","slug":"容器","permalink":"http://yoursite.com/tags/容器/"}]},{"title":"Socket五大I/O模型","date":"2020-05-01T16:09:31.000Z","path":"2020/05/02/No15-Socket在Linux中的五大IO模型/","excerpt":"预备知识用户态与内核态​ 从宏观上来看，Linux操作系统的体系框架可以分为用户态与内核态，如下图所示。根据Linux系统“一切皆文件”的最高指示精神，内核从本质上来看当然也可以被认为是一种软件，他控制着计算机的硬件资源（包括CPU资源、I/O资源、存储资源等等），他需要为上层用户态中的应用系统提供运行的环境。用户态中程序的执行相应的必须要依托于内核所提供的资源。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。","tags":[{"name":"Socket","slug":"Socket","permalink":"http://yoursite.com/tags/Socket/"},{"name":"I/O模型","slug":"I-O模型","permalink":"http://yoursite.com/tags/I-O模型/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"趣谈计算机网络协议-传输层之UDP协议","date":"2020-04-30T10:55:04.000Z","path":"2020/04/30/No14-趣谈计算机网络协议-传输层之UDP协议/","excerpt":"前言​ 上一篇谈了传输层的TCP协议，这篇来介绍一下TCP是如何实现拥塞控制，以及另一个非常重要的UDP协议，并对两个协议进行一番比较。 TCP的拥塞控制 为什么会出现拥塞？ 首先，发送的数据速率是收到发送方、接收端、网络三重制约的。同时，每一个TCP传输都希望能够占据满额的数据传送速率。如果对此不加以控制，网络就会出现拥塞。 拥塞控制的解决方法： TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。","tags":[{"name":"传输层","slug":"传输层","permalink":"http://yoursite.com/tags/传输层/"},{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"},{"name":"UDP","slug":"UDP","permalink":"http://yoursite.com/tags/UDP/"}]},{"title":"趣谈计算机网络协议-传输层之TCP协议","date":"2020-04-30T08:50:38.000Z","path":"2020/04/30/No13-趣谈计算机网络协议-传输层/","excerpt":"前言​ 太久没来更新技术博客了，主要是由于实验室年底与华为接了一个5G大项目，一直忙于测试与报告写作。直到最近，才把与华为的报告告了一个段落，自己的SCI论文也悲催被拒。意想不到是尽管找了实验室的国际友人修改润色语言，结果审稿专家依然觉得有几处really confused him。现在终于有时间边修改论文，边继续互联网的学习了。今天先从传输层的网络协议开始整理学习，传输层中有两个重要的协议，TCP与UDP，下面对此展开介绍。 运输层概述​ 运输层提供应用层端到端的通信服务。通俗讲，两个主机通讯，就是应用层上的进程之间的通信，也就是转换为进程和进程之间的通信了。网络层的IP协议能将分组准确的发送到目的主机，但是停留在网络层，并不知道要怎么交给我们的主机应用进程，通过前面的学习，我们学习有mac地址，通过mac地址能找到同一个网络下主机，有IP地址，通过ip地址能找到不同网络下的网络，结合mac地址就能找到对应主机，那么怎么找到主机应用进程呢，肯定也有一个东西来标识它，那就是我们常说的端口了。","tags":[{"name":"传输层","slug":"传输层","permalink":"http://yoursite.com/tags/传输层/"},{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}]},{"title":"正则表达式（2）--进阶：回溯法","date":"2019-07-28T11:42:15.000Z","path":"2019/07/28/No12-正则表达式/","excerpt":"上周在某次技术分享会上，听到了一节关于正则表达式的分享。回头来看，自己之前理解的正则实在是一些皮毛而已，跑到这里再来补补课。 没有回溯的匹配假设我们的正则是/ab{1,3}c/，其可视化形式是： 而当目标字符串是”abbbc”时，就没有所谓的“回溯”。其匹配过程是：","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"},{"name":"回溯法","slug":"回溯法","permalink":"http://yoursite.com/tags/回溯法/"}]},{"title":"ELK监控报警系统(3)--SSL解密","date":"2019-07-19T16:00:02.000Z","path":"2019/07/20/No11-ELK监控报警系统-3/","excerpt":"问题发现前两天在测试环境部署ElastAlert的时候，遇到了些问题，来这里分享一下，权当做个记录，踩个坑。 通过运行elastalert-create-index为ElastAlert创建回写索引时，和之前在本地部署的不太一样，显示Connection refused。 随后，我用curl命令去访问服务器的9200端口（es端口），返回结果：Empty reply from server。 Google一下，在Stack Overflow等开源平台上面找到了回答，原来测试环境采用HTTPS协议，仅用curl命令去访问https网站，显然是不可以的。 CURL对HTTPS的支持要通过--cacert, --capath, --with-ca-bundle来实现。 那有好奇宝宝又要问了，现在大部分网站都从HTTP转向HTTPS了，我用curl命令去访问http://www.google.com ，为何还是可以返回正确网页的结果？ 其实这个问题，打开浏览器，打开F12开发者模式，在地址栏中输入http://www.google.com ，可以发到网页会被redirect(自定向)到https://www.google.com ，http状态码为307 internal redirect。 至此，又有第二位好奇宝宝问了，为什么大量的网站都从http协议转向了https协议，http和https的区别是啥？ 那么遵循多问一个为什么原则，今天我们探究一下这个多出来的s，也就是SSL（TLS）到底是什么？","tags":[{"name":"ELK","slug":"ELK","permalink":"http://yoursite.com/tags/ELK/"},{"name":"SSL","slug":"SSL","permalink":"http://yoursite.com/tags/SSL/"},{"name":"对称加密","slug":"对称加密","permalink":"http://yoursite.com/tags/对称加密/"},{"name":"非对称加密","slug":"非对称加密","permalink":"http://yoursite.com/tags/非对称加密/"}]},{"title":"ELK监控报警系统(2)","date":"2019-07-07T09:55:56.000Z","path":"2019/07/07/No10-ELK监控报警系统-2/","excerpt":"简介Elastalert是由Yelp团队使用Python 2.6 开发的简单开源(https://github.com/Yelp/elastalert) 框架，用于警告Elasticsearch中的异常数据。 我们使用Elasticsearch，Logstash和Kibana（Elastic Stack）来管理不断增加的数据和日志来管理不断增加的数据和日志。 Kibana非常适合可视化和查询数据，但到它需要一个配套工具来警告我们的数据不一致。 因此，如果需要实时地将数据写入Elasticsearch并希望在数据与某些规则匹配时进行告警，Elastalert完美适配。 官方文档（https://elastalert.readthedocs.io/en/latest/） 快速安装上手教程可借鉴查看（https://www.jianshu.com/p/e21a82e56b86） 配置环境Centos 7 工作原理概述ElastAlert可靠，高度模块化，易于设置和配置。它的工作原理是将Elasticsearch与Elastalert的规则类型和警报相结合。定期查询Elasticsearch并将数据传递给规则，每个规则都定义了查询，规则类型和一组警报。该规则确定何时找到匹配项。当匹配发生时，即会触发一个或多个警报。 ElastAlert包含几种具有常见监控范例的规则类型：","tags":[{"name":"ELK","slug":"ELK","permalink":"http://yoursite.com/tags/ELK/"}]},{"title":"ELK监控报警系统(1)","date":"2019-07-07T05:02:54.000Z","path":"2019/07/07/No9-ELK监控报警系统-1/","excerpt":"这段时间的工作任务主要是搭建一个监控报警系统，工作方向偏运维。目前最流行的监控报警系统无疑就是ELK了，因此今天先分享一下ELK的搭建安装。 要研究任何一个东西，我认为都得分几步走。 第一，了解这个东西是什么？功能是啥？ 第二，运行，配置环境，先将最简单的demo跑起来看看。 第三，要知道运行原理，这就涉及到阅读源码，可以先从Git上迁出最简单的0.1（或1.0）版本先行理解。 第四，修改源码，使之符合自己的需求。 接下来就先了解一下什么是ELK。 什么是ELK？ELK平台是当前应用比较广泛的一套开源实时日志分析解决方案。ELK由ElasticSearch、Logstash和Kiabana三个开源工具组成。 Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。","tags":[{"name":"ELK","slug":"ELK","permalink":"http://yoursite.com/tags/ELK/"}]},{"title":"HTTP头部信息之gzip","date":"2019-07-06T02:48:46.000Z","path":"2019/07/06/No8-HTTP头部信息之gzip/","excerpt":"昨天聊了HTTP头部信息之csp，今天来学习一下gzip。实际两者都可以在HTTP头部信息中找到相应的字段。 什么是gzipgzip最早是一个Linux命令，用于压缩文件。后被用于HTTP协议上，是一种用来改进WEB应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，才能得以启用。 目前主流的浏览器Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。gzip压缩比率在3到10倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。 如何启用gzip要检测gzip，首先要知道gzip是如何工作的，其工作原理如下图所示。 1、由客户端向服务器发送请求信息，可在request header中设置属性accept coding，下图中的accept coding字段意味着客户端（浏览器）支持gzip, deflate, br三种压缩方式。 其中deflate方法与gzip几乎别无二致，不做过多展开。br 算法是由Google在2015年9月新近提出的压缩算法，经过实验，可以在gzip算法的压缩率提升20%，而压缩与解压缩速度则大致不变。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"gzip","slug":"gzip","permalink":"http://yoursite.com/tags/gzip/"}]},{"title":"HTTP头部信息之csp","date":"2019-07-05T13:33:42.000Z","path":"2019/07/05/No7-HTTP头部信息csp与gzip检测/","excerpt":"最近在某公司实习，一直没有时间整理所学。希望以后可以做到每周必更。 HTTP的头部信息包含许多有用的内容，今天我们重点来聊两个，分别是csp与gzip。 什么是CSP？首先来谈谈CSP。根据维基百科的定义，CSP，即内容安全策略(Content Security Policy）是一种计算机安全标准，旨在防御跨站脚本（XSS）、点击劫持等代码注入攻击，阻止恶意内容在受信网页环境中执行。 这里就需要讲到XSS，一个网页安全漏洞。 网站的安全模式源于“同源策略”，web浏览器允许第一个web页面中的脚本访问页面中的数据，但前提是两个web页面具有相同的源。此策略防止一个页面的恶意脚本通过该页面的文档访问另一个网页上的敏感数据。 在某些情况下，同源策略的限制性如果太强，其实是不太友好的，比如说大型网站的子域之间的数据传递，开发过程中的一些调试等；但是人类是比较聪明的，利用一些技术、从而放宽策略。 但是，跨网站脚本 (XSS)攻击可通过欺骗网站提供恶意代码和计划好的内容来绕过同源政策：通过寻找将恶意脚本注入网页，攻击者可以获得对敏感页面内容，会话cookie以及浏览器代表用户维护的各种其他信息的提升访问权限。 为了缓解很大一部分潜在的跨脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。简单来说这一技术就是： 开发者明确告诉客户端（制定比较严格的策略和规则），哪些外部资源是可以加载和执行的 ，即使攻击者发现漏洞，但是它是没办法注入脚本的。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"CSP","slug":"CSP","permalink":"http://yoursite.com/tags/CSP/"}]},{"title":"Python web development with Flask(4) -- flask-script模块与click模块","date":"2019-06-17T14:13:49.000Z","path":"2019/06/17/No6/","excerpt":"Flask-scriptFlask Script扩展提供向Flask插入外部脚本的功能，包括运行一个开发用的服务器，一个定制的Python shell，设置数据库的脚本，及其他运行在web应用之外的命令行任务；使得脚本和系统分开； Flask Script和Flask本身的工作方式类似，只需定义和添加从命令行中被Manager实例调用的命令； 先来看一个简单的例子： 1234567891011121314# manage.py# 导入库from flask_script import Managerfrom debug import app# 实例,参数为Flask实例manager = Manager(app)# 使用command实例的@command修饰符@manager.commanddef hello(): print(&apos;hello world&apos;)if __name__ == &apos;__main__&apos;: manager.run()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"web development","slug":"web-development","permalink":"http://yoursite.com/tags/web-development/"}]},{"title":"Python web development with Flask(3)--Blueprints 蓝图","date":"2019-06-17T06:22:33.000Z","path":"2019/06/17/No5/","excerpt":"白话版 在基于Flask框架的web开发学习中，遇到了Blueprints （蓝图）的概念，转载一篇知乎上关于此的高分回答。 恩，理解「蓝本」对于没有接触其他Web编程实现的Python+Flask新手而言，是一个不好迈过的坎儿。 我得用「比喻」的方式穿插讲述一下「蓝本」，方便你更好理解，问这个问题估计是新手，所以我啰嗦点好了。 首先，提一下概念，「蓝本」的对应官方词汇是「Blueprint」，中译还有「蓝图」这种叫法，是一种东西。你去餐馆吃饭，点一些菜，你一定吃过「麻辣香锅」这种东西。你可以点一些杂七杂八的菜，选好口味，之后一个碗儿端上来，你吃的很滋味，并且也会觉得这种「一锅端」的方式很好，毕竟不会一道吃完等下一道啊，一起上来热乎乎的多好。并且吃的很少的时候，一点点的菜单独用一个碗儿装也是有点「装逼」的事情。 假如你一个人一己之力要写一个BBS（论坛系统）的话，上面的这个例子，其真实写照是初期功能很弱时，可能页面不多，实现的功能也很少。可能首页就是一个帖子列表，允许用户发布帖子，并且不涉及登录退出、会员等级、权限管理等，你想着，那是后面再说的事情。于是，你将网站主干代码写在一个run.py文件里，让网站成功的跑了起来，你觉得这样实现很方便，快捷。 如果我让你这个时候把run.py理一下，能独立出来的独立成其他的文件，之后在run.py里导入，你要骂我「装逼」了，没事找事。是的，「蓝本」并不适合用来构建想当简单的网站系统。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"web development","slug":"web-development","permalink":"http://yoursite.com/tags/web-development/"}]},{"title":"python中的多进程使用总结（1）","date":"2019-06-14T13:31:43.000Z","path":"2019/06/14/No4/","excerpt":"今天去一家公司面试，在笔试过程中遇到了多线程、多进程等问题，之前的学习中对此内容都是一笔带过，未曾深入了解。此外，之后希望完成一个基于Django的仿淘宝秒杀系统，将不可避免地遇到多进程、分布式的编程问题，因此今天在此系统性地学习多进程、多线程，并做一个总结。 首先来谈谈多进程。 fork() in Linux/UnixLinux 系统提供了一个fork()系统调用，普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。来看代码：","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"多进程","slug":"多进程","permalink":"http://yoursite.com/tags/多进程/"}]},{"title":"Python 中的正则表达式","date":"2019-06-12T15:59:58.000Z","path":"2019/06/12/No3/","excerpt":"这节来聊聊Python中的正则表达式。字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 通过使用正则表达式，可以： 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python web development with Flask(2)","date":"2019-06-09T14:23:55.000Z","path":"2019/06/09/No2/","excerpt":"上节聊了Flask程序的运作方式，以及构建一个外部可访问的Flask程序的方法。在本节中，主要聚焦于隐藏在Flask背后的重要角色——HTTP，看看Flask是如何与之进行前后端交互的。 请求循环效应随意输入一个网址，按下Enter，浏览器便会显示一个对应网页。在其背后，实际上是程序正在运行着，它负责接收用户的请求，并把对应的内容返回给客户端，显示在用户的浏览器上。事实上，每一个Web应用都包含这种处理模式，即“请求-响应循环(Request-Response)。注：客户端（Client Side）是指用来提供给用户的与服务器通信的各种软件；服务器端（Server Side）则指为用户提供服务的服务器，也是我们的程序运行的地方。 这是每一个Web程序的基本工作模式，如果再进一步，HTTP在整个流程中起到了至关重要的作用，它是客户端和服务器端之间沟通的桥梁。 当用户访问一个URL，浏览器便生成对应的HTTP请求，经由互联网发送到对应的Web服务器。Web服务器接收请求，通过WSGI将HTTP格式的请求数据转换成我们的Flask程序能够使用的Python数据。在程序中，Flask根据请求的URL执行对应的视图函数，获取返回值生成响应。响应依次经过WSGI转换生成HTTP响应，再经由Web服务器传递，最终被发出请求的客户端接收。浏览器渲染响应中包含的HTML和CSS代码，并执行JavaScript代码，最终把解析后的页面呈现在用户浏览器的窗口中。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"web development","slug":"web-development","permalink":"http://yoursite.com/tags/web-development/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Python web development with Flask(1)","date":"2019-06-09T03:21:53.000Z","path":"2019/06/09/No1/","excerpt":"前言Flask是目前最为流行的Python Web框架之一。Flask仅仅保留了Web框架的核心，其他功能都交由扩展实现。因其灵活性，越来越多的公司选择Flask作为Web框架，知名公司有Netflix、Reddit和豆瓣等，这也说明了Flask能够经受大型项目的挑战，适应各种需求。 开发环境OS ：Windows 10 (x64)软件 : Pycharm版本管理： Git Hello, Flask!这是一个最小的Flask程序，仅需5行就能够实现。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"web development","slug":"web-development","permalink":"http://yoursite.com/tags/web-development/"}]},{"title":"Hello World","date":"2019-06-09T03:11:26.209Z","path":"2019/06/09/hello-world/","excerpt":"","tags":[]}]